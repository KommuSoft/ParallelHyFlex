\section{Systeem}

\paragraph{}
Het beschrijven van parallelle algoritmes is vaak complex. In dit hoofdstuk zullen we eerst een algemeen overzicht geven van het volledige systeem. Daarna bespreken we welke probleemafhankelijke componenten we hebben toegevoegd om dit systeem beter te doen werken. Vervolgens beschrijven we de principes achter het parallel uitvoeren van de hyperheuristieken. We eindigen met een bondig overzicht en bespreken welke inzichten uit het vorige hoofdstuk relevant waren voor de implementatie van dit systeem.

\subsection{Overzicht}

Hyperheuristieken kiezen uit een divers aanbod aan heuristieken. De meeste van deze heuristieken verschillen in tijdgebruik. Daarom is het niet evident om systemen te implementeren met een hoge granulariteit: indien \'e\'en van de processoren een \abls{} \abh{} kiest, zal deze veel rekentijd gebruiken en andere processoren blokkeren. \abmt[M]{} \abhn{} daarentegen worden meestal vrij snel uitgevoerd waardoor de communicatie over deze heuristiek waarschijnlijk meer tijd zo vragen dan de eigenlijke heuristiek uitvoeren. Zeker wanneer we een schaalbaar model willen bouwen, is een model met hoge granulariteit dus niet gewenst.

\paragraph{}
We kunnen er voor opteren om de heuristieken zelf in parallel uit te voeren ofwel dus \emph{type 1}-parallellisatie van \emph{Crainic and Toulouse}\cite{crainicAndToulouse}. Het nadeel van deze aanpak is dat de onderliggende heuristieken zelf aangepast moeten worden voor een parallelle context. Bovendien verliezen we rekenkracht bij het opstarten en aflopen van een heuristiek: de opdracht moet eerst naar de verschillende processoren worden gecommuniceerd. Op het moment dat alle processoren hun werk be\"eindigt hebben moet men bovendien de resultaten terug naar de centrale processor sturen. Tussen het moment dat de processoren een vorige heuristiek hebben afgewerkt en een nieuwe opdracht krijgen, wordt de rekenkracht niet gebruikt. Sommige heuristieken zijn bovendien niet eenvoudig te parallelliseren. In het geval van een mutatie bijvoorbeeld zal in sommige gevallen het doorsturen van een oplossing meer tijd vragen dan de mutatie zelf uit te voeren.

\paragraph{}
Daarom hebben we geopteerd voor een model waarbij elke processor de volledige heuristieken uitvoert. Deze vorm valt dus onder \emph{Type 3}-parallellisatie. De processen werken niet volledig onafhankelijk: oplossingen kunnen worden uitgewisseld naar andere processoren. Op die manier kunnen met behulp van een kruisingsoperator ofwel \emph{\abco{}} sterke delen uit een oplossing worden uitgewisseld. Oplossing worden uitgewisseld zonder dat de processor wacht tot de oplossing is doorgestuurd. We hopen hiermee de effici\"entie verder te kunnen opdrijven.

\paragraph{}
Met behulp van \emph{afdwingbare beperkingen}, een concept die we in de volgende sectie introduceren kunnen we ook de zoekruimte beperken. Dit is het \emph{Type 2}-parallellisme: per processor wordt er een op geregelde tijdstippen een nieuwe zoekruimte berekend waarin dan meer geconcentreerd wordt gezocht. Men dient echter te voorkomen dat teveel processoren hetzelfde deel van de zoekruimte afzoeken. Daarom vinden onderhandelingen tussen de verschillende processoren plaats. Ook deze onderhandeling vinden asynchroon plaats.

\paragraph{}
Communicatie kan een significante overhead voor een algoritme betekenen. Vooral het \emph{serializeren} en \emph{deserializeren} van data is een taak die aan processoren wordt uitbesteed en dus rekenkracht vergt. In de meeste bestudeerde implementaties verloopt de communicatie ofwel synchroon (de uitvoering wordt geblokkeerd op verschillende punten in de tijd om een boodschap te verzenden of te ontvangen), ofwel met behulp van verschillende ``\emph{threads}''. Wanneer men met \emph{threads} kunnen manipulaties op gegevensstructuren tegelijk plaatsvinden wat tot inconsistentie kan leiden. Een oplossing is gebruik maken van \emph{locks} of andere synchronisatie-directieven. Deze directieven introduceert nieuwe vormen van verlies aan rekenkracht.

\paragraph{}
Dit is de motivatie om in het geval van \emph{ParHyFlex} met \'e\'en \emph{thread} te werken en communicatie asynchroon te verwerken. Doordat het toepassen van heuristieken de kern is van iedere hyperheuristiek kunnen we de assumptie maken dat gedurende het hele proces deze methodes zullen worden opgeroepen. Nadat een heuristiek is uitgevoerd controleert het systeem of er nieuwe berichten zijn toegekomen en wordt er \'e\'en bericht verwerkt. De argumentatie is dat sommige berichten ertoe leiden dat de processor zelf berichten uitstuurt en zo een domino-effect teweeg brengt. Door slechts \'e\'en bericht te verwerken hopen we de communicatie in de hand houden. Hierdoor garanderen we dat een minimale hoeveelheid rekenkracht in de heuristieken wordt ge\"investeerd. De details in verband me de communicatie worden verder toegelicht in \appref{a}.

\paragraph{}
Als we de assumptie maken dat er hoogstens \'e\'en bericht zal toekomen tijdens de uitvoer van een heuristiek zou dit bovendien niet tot significant ander gedrag mogen leiden. De hyperheuristiek maakt een keuze op basis van eigen ervaring en ervaring die door middel van boodschappen wordt doorgestuurd. Vermits deze boodschappen worden verwerkt alvorens de hyperheuristiek opnieuw controle krijgt over de processor, zal de hyperheuristiek met dezelfde data een nieuwe keuze maken. Ook wanneer men een operator toepast terwijl men een oplossing in het geheugen inleest verandert er niks: de operator zal immers altijd de oplossing gebruiken die op dat moment in het geheugen zit. Een bericht die ertoe leidt dat de zoekruimte wordt aangepast heeft wel effect: als we de zoekruimte pas achteraf aanpassen zal dit andere resultaten opleveren dan wanneer we dit doen wanneer het bericht binnenkomt.

\paragraph{}
Het systeem omvat \'e\'en hi\"erarchisch aspect: er is \'e\'en processor die het probleem inleest en naar de verschillende processoren stuurt. Wanneer de tijd afloopt zal deze processor ook de oplossingen van de verschillende processoren verzamelen en de beste oplossing rapporteren. Naast deze communicatie werkt het systeem volledig in een \emph{peer-to-peer} mode. Heel wat implementaties werken wel volgens het \emph{master-slave} model\cite{}. Dit heeft tot gevolg dat \'e\'en van de processen zich meer met communicatie bezighoudt wat tot een onbalans kan leiden in het systeem (we verwachten dat deze processor minder kwalitatieve oplossingen naar andere processoren zal sturen wat ertoe kan leiden dat de evolutie naar betere oplossingen wordt afgeremd). In andere implementaties\cite{} stelt men een processor aan die zich uitsluitend met communicatie bezighoudt. De meeste publicaties rapporteren dat deze processor meestal 90\% van de tijd geen taken uitvoert. Dit leidt ertoe dat de processor zijn rekenkracht niet optimaal gebruikt. Bovendien is het complexer om resultaten te rapporteren: het weglaten van deze processor in de berekeningen leidt tot optimistische resultaten.


\subsection{Probleemafhankelijk gedeelte}

We werken echter in een parallelle context. Daarom is het interessant dat het probleemafhankelijke gedeelte meer functionaliteiten ter beschikking stelt die uitgebuit kunnen worden door het bovenliggende systeem. Concreet denken we hierbij aan vier zaken: \emph{afstandmetrieken}, \emph{ervaring-generatoren}, \emph{zoekruimte beperkers} en \emph{multi-objectieven}

\subsubsection{Afstandmetrieken}
\abhf{} laat problemen een functie aanbieden die twee oplossingen met elkaar kan vergelijken. Deze functie kunnen we theoretisch omvormen tot een afstandsmetriek (we stellen de afstand tussen twee dezelfde oplossingen gelijk aan 0, en tussen twee verschillende aan een arbitraire constante groter dan 0). Deze metriek levert echter weinig informatie op. In een sequenti\"ele context gebruikt men soms het aantal mutaties die tussen een oplossing en \'e\'en van zijn voorouders om de afstand af te schatten. Dit is natuurlijk slechts een benadering. In het geval van parallelle uitvoer zullen we bovendien meestal niet over deze informatie beschikken. Daarom is het nuttig om de afstand tussen twee oplossingen te kunnen inschatten. In het geval de afstand geen triviaal gegeven is, kan men verschillende afstandsmetrieken defini\"eren en beslist de bovenliggende hyperheuristiek over de waarde van de metrieken. Een afstandmetriek is dus gedefinieerd als:
 \begin{equation}
  \delta_i:\SolSet^2\rightarrow\RealSet^+
 \end{equation}
 
\subsubsection{Ervaring-generatoren}
Elk proces draait een eigen hyperheuristiek en komt een sequentie heuristieken tegen. Uitwisselen van de sequentie kan potentieel een voordeel opleveren omdat de hyperheuristieken met meer kennis van zaken kunnen beslissen. Het doorsturen van alle heuristieken is doorgaans niet mogelijk omdat dit een te grote druk op het netwerk zet en bovendien de overige processoren te veel rekenkracht zouden investeren in het analyseren van de ontvangen oplossingen. Door het uitwisselen van ervaring, een compacte voorstelling van beschouwde oplossingen, zouden we dit probleem kunnen oplossen.

\subsubsection{Zoekruimte-beperkers}
Wanneer processoren oplossingen met elkaar uitwisselen lopen we de kans dat de verschillende processoren op termijn vergelijkbare populaties onderhouden. Dit laatste is nuttig wanneer sterke oplossingen in de buurt liggen van de oplossingen in de populatie. Indien de populaties echter rond eenzelfde lokaal optimum liggen, is dit nefast. In dat geval proberen alle processoren het lokale optimum te zoeken in een eenzelfde gebied, en wordt migratie naar mogelijk betere oplossingen in een ander gebied minder evident. Het introduceren van een component die diversificatie afdwingt kan helpen te voorkomen dat we op ijle populaties stuiten.

\subsubsection{Multi-objectieven}
Alle processoren proberen hetzelfde optimalisatieprobleem op te lossen. Door extra objectieven te introduceren, kunnen we echter een meer divers zoekproces aanbieden. Deze extra objectieven zijn eerder virtueel en dienen meer als een \emph{tie-breaker} in bijvoorbeeld gevallen waarbij twee oplossingen dezelfde fitness-waarde hebben.

\subsubsection{Afdwingbare beperkingen als probleemonafhankelijke ervaring}

Een probleem bij het genereren van \emph{ervaring} en het beperken van de \emph{zoekruimte} is dat dit op een probleemonafhankelijke manier dient te gebeuren: de bovenliggende hyperheuristiek heeft geen details over de structuur van de configuraties en kan bijgevolg niet zelf de zoekruimte beperken of conclusies genereren. We kunnen ervaring voorstellen als een object waar de hyperheuristiek de specificaties niet van kent, maar in dat geval moet ervaring wel enkele algemene functionaliteiten kunnen aanbieden die nuttig zijn. Om dit probleem op te lossen voeren we het concept van een \emph{afdwingbare beperking} in.

\begin{definition}[Afdwingbare beperking]
Een \emph{afdwingbare beperking} is een 3-tuple: $\tupl{c,c^+,c^-}$. $c:\SolSet\rightarrow\BoolSet$ is hierbij een functie die controleert of een gegeven oplossing aan een bepaalde voorwaarde voldoet. $c^+:\SolSet\rightarrow\SolSet$ is een functie die een gegeven oplossing minimaal kan aanpassen zodat deze aan de voorwaarde voldoet. $c^-:\SolSet\rightarrow\SolSet$ past oplossingen minimaal aan zodat ze niet aan de voorwaarde voldoen. De set van alle afdwingbare beperkingen die we op een probleem kunnen toepassen noteren we als $\HypSet$.
\end{definition}

We kunnen een afdwingbare beperking als een vorm van ervaring zijn. In de loop der tijd kunnen we immers een hypothese ontwikkelen dat sterke oplossingen aan een bepaalde voorwaarde voldoen (bijvoorbeeld een variabele in het probleem krijgt een vaste waarde). We kunnen dan oplossingen aantrekken naar de hypothese door $c^+$ op willekeurige oplossingen toe te passen. Anderzijds kunnen we ook oplossingen afstoten van de hypothese met $c^-$. De bovenliggende hyperheuristiek dient echter niet op de hoogte te zijn welke voorwaarden een concrete afdwingbare beperking stelt, zolang deze maar de oplossingen kan manipuleren.

\paragraph{}
Afdwingbare beperkingen kunnen we eveneens gebruiken om de zoekruimtes te beperken. Elk proces kan immers een aantal afdwingbare beperkingen gebruiken om een bepaalde zoekruimte te beschouwen, terwijl het de afdwingbare beperkingen van de andere processoren gebruikt om uit de buurt van de andere zoekruimtes te blijven.

\paragraph{}
De hyperheuristieken zelf kunnen geen ervaring genereren, ze hebben immers geen weet van de structuur van een oplossing. Daarom zal het specifieke probleem dus een set functies defini\"eren die we \emph{hypothese-generatoren (hypogen)} noemen:
\begin{definition}[Hypothese-generator]
Een \emph{hypothese-generator (hypogen)} $g_i:\SolSet^{n_{g_i}}\rightarrow\HypSet$ is een functie die op basis van een set oplossingen een afdwingbare beperking kan genereren.	
\end{definition}

\subsection{Probleemonafhankelijk gedeelte}

Het probleemonafhankelijke gedeelte wordt ge\"implementeerd door de hyperheuristiek en kan dus los gezien worden van \emph{ParHyFlex}. Het probleemafhankelijke gedeelte biedt echter functionaliteiten aan waarvoor we ondersteuning kunnen bieden in het probleemonafhankelijke gedeelte.

\paragraph{}
In \emph{ParHyFlex} werden daarom de volgende componenten ge\"implementeerd: \emph{uitwisselen van oplossingen}, \emph{afbakenen van zoekruimtes}, \emph{genereren van ervaring} en \emph{onderhandelen over een nieuwe zoekruimte}. In de volgende subsubsecties zullen we deze taken verder bespreken.

\subsubsection{Uitwisselen van oplossingen}

Elke processor werkt met een eigen lokaal geheugen, maar reserveert ook plaats voor de geheugens van de andere processoren. Op het moment dat een nieuwe oplossing naar een lokale geheugencel geschreven wordt, zal op basis van een \emph{uitwisselingsstrategie} beslist worden met welke processoren deze oplossing zal worden gedeeld. De taak van het verzenden en ontvangen van een oplossing samen met een reeks uitwisselingsstrategie\"en wordt ondersteund door \emph{ParHyFlex}.

\subsubsection{Afbakenen van de zoekruimte}
 
De zoekruimte bewaken is ook een verantwoordelijkheid van \emph{ParHyFlex}. Hiervoor voorziet men twee sets van afdwingbare beperkingen: positieve en negatieve. Telkens wanneer er een nieuwe oplossing wordt gegenereerd\footnote{Of via uitwisseling in het geheugen wordt ingeladen.} zal \emph{ParHyFlex} alle beperkingen in de positieve set afdwingen en \'e\'en beperking uit de negatieve set. Het afdwingen gebeurt in een willekeurige volgorde. Dit komt omdat de beperkingen met elkaar kunnen interfereren: een eerste beperking kan een variabele op \'e\'en waarde zetten waarna de volgende beperkingen deze wijziging weer ongedaan maakt. Men kan dit probleem proberen op te lossen door alle permutaties uit te proberen in de hoop dat \'e\'en mutatie toch tot het correcte resultaat leidt. Dit is echter niet noodzakelijk zo, en bovendien vereist een dergelijke oplossing exponenti\"ele tijd. We nemen aan dat de beperkingen meestal minimaal met elkaar interfereren en dat een zoekruimte niet strikt moet worden bewaakt. De hierboven vernoemde strategie is niet verplicht. Men kan door een interface te implementeren een andere strategie hanteren.

\subsubsection{Genereren van Ervaring}
 
Telkens wanneer \'e\'en van de processoren een nieuwe oplossing voortbrengt, kan hij deze oplossing -- samen met andere oplossingen -- omzetten in een afdwingbare beperking. Een processor kan echter niet alle beperkingen blijven bewaren: het uitwisselen van ervaring dient snel te gebeuren, we dienen een voldoende grote zoekruimte te behouden en bovendien kunnen we net een beperking genereren die het zoeken de foute kant opstuurt. Daarom maken we gebruik van een \emph{ervaring-set}, een set van vaste grootte waar gegenereerde beperkingen in worden bewaard. De elementen in de set worden telkens ge\"evalueerd: telkens wanneer er een nieuwe oplossing wordt gegenereerd, zal de \emph{ervaring-set} kijken aan welke beperkingen de oplossing voldoet. Op basis van de fitness-waarde van de oplossingen kunnen de beperkingen dan ge\"evalueerd worden. Door de lijst van fitness-waardes op te delen in waardes waarbij de beperking wordt gerespecteerd en waardes waarbij dat niet het geval is, ontstaan twee sets aan punten. Met een online algoritme\cite[p. 232]{citeulike:175026} berekenen we voor beide sets het gemiddelde en de variantie. Door de evaluaties van beide sets als onafhankelijke normale verdelingen te beschouwen, kunnen we de kans uitrekenen dat een fitness-waarde van een oplossing die aan de voorwaarde voldoet kleiner is dan de oplossing die niet aan de voorwaarde voldoet. Naarmate de kans groter wordt maken we de assumptie dat de beperking beter is. Omdat de gegenereerde beperkingen ook fout kunnen zijn, dienen we de set regelmatig van nieuwe hypotheses te voorzien, dit proces heet \emph{amnesie}. \emph{Amnesie} wordt op geregelde tijdstippen toegepast: oude hypotheses worden uit de set gehaald op plaats te maken voor nieuwe hypotheses. We wensen dat sterke hypothese meer kans maken om te overleven maar wel de kans lopen om te verdwijnen. Daarom rangschikken we de beperkingen op basis van hun evaluatie. De kans dat de hypothese vervolgens uit de set wordt gehaald berekenen we vervolgens op basis van de Benford-verdeling\cite{citeulike:748130}.

\subsubsection{Onderhandelen over een nieuwe zoekruimte}

Elke processor houdt een \emph{ervaring-set} bij. Het is de bedoeling dat deze ervaring wordt gebruikt om een nieuwe zoekruimte af te dwingen. Bovendien kan ervaring uitgewisseld worden met andere processoren zodat deze later ook hun zoekruimtes aanpassen. Tegelijk willen we voorkomen dat de zoekruimtes te homogeen worden en dus potentieel sterke oplossingen genegeerd worden. Dit zijn de taken van de \emph{onderhandelaar}. De \emph{onderhandelaar} is een component die af en toe geactiveerd wordt. Een deel van de afdwingbare beperkingen worden uit de \emph{ervaring-set} gehaald om opgenomen te worden in het positieve component van de \emph{zoekruimte}. Deze beperkingen worden via groepscommunicatie doorgestuurd naar de andere processoren. Een deel van de ontvangen beperkingen komen terecht in de \emph{ervaring-set} een andere deel vormt de basis van het negatieve gedeelte van de \emph{zoekruimte}. Omdat een deel van de afdwingbare beperkingen vanaf dan in de \emph{ervaring-set} van de andere processoren wordt ge\"evalueerd (met een andere zoekruimte), is men in staat om zo'n beperking op een objectievere manier te evalueren\footnote{Sommige afdwingbare beperkingen leiden immers enkel tot sterke resultaten in een bepaalde \emph{zoekruimte}.}.

\subsection{Invloed van eerdere studies}



\subsection{Overzicht}

\importtikz[1.4]{parhyflexstructure}{parhyflexstructure}{Structuur van \emph{ParHyFlex}.}
Op \imgref{parhyflexstructure} geven we schematisch de structuur van \emph{ParHyFlex} weer.	De componenten die gemarkeerd worden met een asterisk, zijn component die niet aanwezig zijn in \emph{HyFlex}. Het grijze blok stelt de kern van het \emph{ParHyFlex} systeem voor.%TODO

\paragraph{}
Een deel van de geheugencellen is gemarkeerd met een schuine streep. Deze geheugencellen stellen vreemd geheugen voor waarvan er lokaal een kopie wordt bijgehouden. De geheugencellen kunnen uitgelezen worden, maar er kan geen oplossing naar geschreven worden.

\paragraph{}
\importtikz[1.4]{parhyflexwerking}{parhyflexwerking}{Schematische voorstelling van de kern van \emph{ParHyFlex}.}
Op \imgref{parhyflexwerking} beschrijven we kort het proces die een berekende of ontvangen oplossing doormaakt. Deze oplossing -- op de figuur $s_1^{(0)}$ -- wordt eerst aangepast door de zoekruimte: alle positieve hypotheses en \'e\'en negatieve hypothese worden toegepast op de oplossing en wordt aangepast tot $s_1^{(E)}$ die binnen de zoekruimte valt. De fitness-waarde wordt berekend en de evaluaties van de reeds aanwezige hypotheses in de ervaring-set worden aangepast (de data wordt voor elke hypothese opgenomen in \'e\'en van de twee normale verdelingen). Verder wordt met behulp van \'e\'en van de hypothesegeneratoren  een hypothese gegenereerd die met een bepaalde kans opgenomen wordt in de ervaring-set. De oplossing wordt vervolgens in het geheugen opgenomen en eventueel doorgestuurd naar andere processoren.

\paragraph{}
Op geregelde tijdstippen treed er amnesie op in de \emph{ervaring-set}: een deel van de hypothese worden uit de set verwijdert. Dit gebeurt op basis van de twee normale verdelingen per hypothese. Op die manier kan men zich ontdoen van foute hypothese, en maakt men ruimte voor nieuwe hypotheses.

\paragraph{}
Op vaste tijdsintervallen zal de \emph{onderhandelaar} een deel van de hypotheses uit de \emph{ervaring-set} halen. Een deel van deze hypotheses vormen de nieuwe positieve set van de \emph{zoekruimte}. De overige worden doorgestuurd in de \emph{ervaring-set} van de andere processoren ge\"injecteerd. Een deel van de doorgestuurde hypotheses vormt ook een basis van de negatieve set van de \emph{zoekruimte}.

\paragraph{}
De figuur toont de verschillende stromen van informatie: volle lijnen duiden op informatiestromen die lokaal worden uitgevoerd. Streepjeslijnen duiden op informatie die de processor uitstuurt naar andere processoren. Stippellijnen tonen de informatie die de processor ontvangt van andere processoren.