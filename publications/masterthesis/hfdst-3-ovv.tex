\section{Overzicht}

Vermits de onderliggende heuristieken heel divers kunnen zijn qua tijdsgebruik, lenen hyperheuristiek zich niet goed tot parallellisatie met een hoge granulariteit: indien \'e\'en van de processoren een \abls{} \abh{} kiest, zal deze veel rekentijd in beslag nemen. \abmt[M]{} \abhn{} daarentegen worden meestal vrij snel uitgevoerd. Op het moment dat een processor die een mutatie uitvoert, zijn opdracht heeft voltooid moet deze wachten op een processor met een computationeel veel zwaardere taak. Deze onbalans leidt er bijgevolg toe dat we maar weinig \emph{speed-up} mogen verwachten bij een dergelijke methode.

\paragraph{}
We kunnen er voor opteren om bepaalde heuristieken zelf in parallel uit te voeren, wat valt onder \emph{type 1}-parallellisatie van \emph{Crainic and Toulouse}\cite{crainicAndToulouse}. Het nadeel van deze aanpak is dat de onderliggende heuristieken zelf aangepast moeten worden voor een parallelle context. Bovendien verliezen we rekenkracht bij het opstarten en aflopen van een heuristiek: opdrachten moeten naar de processoren worden gecommuniceerd en de resultaten moeten terug naar een centrale processor vloeien. De aanwezig rekenkracht wordt op deze momenten niet benut waardoor deze methode vrij ineffici\"ent werkt. Sommige heuristieken zijn bovendien niet eenvoudig te parallelliseren: in het geval van een mutatie bijvoorbeeld zal het doorsturen van een oplossing meer tijd vragen dan de mutatie zelf uit te voeren.

\paragraph{}
Daarom hebben we geopteerd voor een model waarbij elke processor zelf een hyperheuristiek uitvoert. Deze vorm valt dus onder \emph{Type 3}-parallellisatie. De processen werken echter niet volledig onafhankelijk: oplossingen kunnen worden uitgewisseld naar andere processoren. Op die manier kunnen met behulp van een kruisingsoperator sterke delen uit een oplossing worden uitgewisseld. Oplossing worden uitgewisseld zonder dat de processor wacht tot de oplossing is doorgestuurd. We hopen hiermee de effici\"entie verder te kunnen opdrijven.

\paragraph{}
Met behulp van \emph{afdwingbare beperkingen}, een concept die we in de volgende sectie introduceren kunnen we ook de zoekruimte beperken. Dit is het \emph{Type 2}-parallellisme: per processor wordt er een op geregelde tijdstippen een nieuwe zoekruimte berekend waarin dan meer geconcentreerd wordt gezocht. Men dient echter te voorkomen dat teveel processoren hetzelfde deel van de zoekruimte afzoeken. Daarom vinden onderhandelingen tussen de verschillende processoren plaats. Ook deze onderhandeling vinden asynchroon plaats.

\paragraph{}
Communicatie kan een significante overhead voor een algoritme betekenen. Vooral het \emph{serialiseren} en \emph{deserialiseren} van data is een taak die aan processoren wordt uitbesteed en dus rekenkracht vergt. In de meeste bestudeerde implementaties verloopt de communicatie ofwel synchroon (de uitvoering wordt geblokkeerd op verschillende punten in de tijd om een boodschap te verzenden of te ontvangen), ofwel met behulp van verschillende ``\emph{threads}''. Wanneer men met \emph{threads} werkt, kunnen manipulaties op gegevensstructuren tegelijk plaatsvinden, wat tot inconsistentie kan leiden. Een oplossing is gebruik maken van \emph{locks} of andere synchronisatie-directieven. Deze directieven introduceert nieuwe vormen van verlies aan rekenkracht.

\paragraph{}
Dit is de motivatie om in het geval van \emph{ParHyFlex} met \'e\'en \emph{thread} te werken en communicatie asynchroon te verwerken. Doordat het toepassen van heuristieken de kern is van iedere hyperheuristiek kunnen we de assumptie maken dat gedurende het hele proces deze methodes zullen worden opgeroepen. Nadat een heuristiek is uitgevoerd controleert het systeem of er nieuwe berichten zijn toegekomen en wordt er \'e\'en bericht verwerkt. Sommige berichten veroorzaken het uitsturen van nieuwe berichten, dit kan een domino-effect teweeg brengt. Door slechts \'e\'en bericht te verwerken hopen we de communicatie beter in de hand te kunnen houden. Bovendien garanderen we dat een minimale hoeveelheid rekentijd zeker in de heuristieken wordt ge\"investeerd. De details in verband me de communicatie worden verder toegelicht in \appref{communication}.

\paragraph{}%TODO: paragaaf behouden?
Als we de assumptie maken dat er hoogstens \'e\'en bericht zal toekomen tijdens de uitvoer van een heuristiek zou dit bovendien niet tot significant ander gedrag mogen leiden. De hyperheuristiek maakt een keuze op basis van eigen ervaring en ervaring die door middel van boodschappen wordt doorgestuurd. Vermits deze boodschappen worden verwerkt alvorens de hyperheuristiek opnieuw controle krijgt over de processor, zal de hyperheuristiek met dezelfde data een nieuwe keuze maken. Ook wanneer men een operator toepast terwijl men een oplossing in het geheugen inleest verandert er niks: de operator zal immers altijd de oplossing gebruiken die op dat moment in het geheugen zit. Een bericht die ertoe leidt dat de zoekruimte wordt aangepast heeft wel effect: als we de zoekruimte pas achteraf aanpassen zal dit andere resultaten opleveren dan wanneer we dit doen wanneer het bericht binnenkomt.

\paragraph{}
\emph{ParHyFlex} werkt volgens het \emph{peer-to-peer} paradigma. Het systeem omvat echter \'e\'en hi\"erarchisch aspect: er is \'e\'en processor die het probleem inleest en naar de verschillende processoren stuurt. Wanneer de tijd afloopt zal deze processor ook de oplossingen van de verschillende processoren verzamelen en de beste oplossing rapporteren. Naast deze communicatie werkt het systeem volledig in een \emph{peer-to-peer} mode. Heel wat implementaties werken wel volgens het \emph{master-slave} model\cite{conf/gecco/LeonMS08,conf/pdp/SeguraSL12}. Dit heeft tot gevolg dat \'e\'en van de processoren zich meer met communicatie bezighoudt wat tot een onbalans leidt in het systeem. In andere implementaties\cite{Rattadilok04adistributed} stelt men een processor aan die zich uitsluitend met communicatie bezighoudt. De meeste publicaties rapporteren dat deze processor meestal 90\% van de tijd wacht op binnenkomende berichten. Dit bemoeilijkt de zaak om resultaten te rapporteren: het weglaten van deze processor in de berekeningen leidt tot optimistische resultaten.