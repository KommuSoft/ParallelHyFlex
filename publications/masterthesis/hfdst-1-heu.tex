\section{Heuristieken}

In de vorige sectie stellen we dat de meeste optimalisatieproblemen \comp{NP-hard} zijn. Dit betekent doorgaans dat we voor grote probleeminstanties er niet in slagen om de optimale configuratie te vinden. In de praktijk lost men deze problemen meestal op met een programma die een benaderende oplossing berekend.

\paragraph{}
Meestal haalt men volgende argumentatie aan om het gebruik van benaderende oplossingen te rechtvaardigen:%TODO: controleer 3
\begin{enumerate}
 \item Een benaderende oplossing kan sneller worden uitgerekend en vormt meestal de grens tussen haalbaar en onhaalbaar.
 \item De fitness-waarde van een benaderende oplossing zal meestal dicht bij deze van het globale optimum liggen.
 \item Praktische problemen zijn meestal complex. Bovendien is de exacte evaluatiefunctie moeilijk of zelfs niet te modelleren\footnote{Soms kan men deze evaluatiefunctie niet modelleren omdat de waarde van de verschillende parameters niet volledig gekend is.}. Er is bijgevolg geen garantie dat het globale optimum ook de werkelijke oplossing weerspiegelt.
\end{enumerate}

\paragraph{}
Een programma die een benaderende oplossing berekent wordt ook wel een heuristiek genoemd:

\begin{definition}[Heuristiek]
Een heuristiek is een programma die gegeven een optimalisatieprobleem $\OpProblem=\tupl{\ConfigSet,\hcfun,\evalfun}$ een oplossing berekent $\goodSol$ in een redelijke tijd. Doorgaans voldoet deze oplossing aan de harde beperkingen ($\fun{\hcfun}{\goodSol}=\true$) en ligt de voorgestelde oplossing $\goodSol$ in fitness-waarde niet ver van de werkelijke oplossing $\bestSol$.
\end{definition}

Deze definitie blijft redelijk vaag en geeft dan ook veel ruimte voor interpretatie. Doorgaans verwachten we dat het algoritme stopt in polynomiale tijd. In de meeste gevallen worden er ook beperkingen gezet op de mate waarin de fitness-waarde $\fun{\evalfun}{\goodSol}$ mag afwijken van de optimale fitness-waarde $\fun{\evalfun}{\bestSol}$, al zijn beide voorwaarden niet strikt noodzakelijk.