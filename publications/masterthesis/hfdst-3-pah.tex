\section{\emph{ParAdapHH}}

Naast het ontwikkelen van een systeem om hyperheuristieken op verschillende processoren te kunnen laten werken, vereist het testen van het systeem dat we een concrete hyperheuristiek ontwikkelen. Een logische keuze is om \emph{AdapHH}, de hyperheuristiek voorgesteld door Mustafa M\i{}s\i{}r te implementeren. We geven eerst een motivatie voor deze hyperheuristiek. Daarna bespreken we in meer detail de werking van de hyperheuristiek samen met de wijzigingen om het systeem op verschillende processoren te laten werken.

\subsection{Motiviatie}

\subsection{Werking}

In het vorige hoofdstuk hebben we de werking van \emph{AdapHH} al op hoog niveau beschouwd. In deze subsectie zullen we de werking in meer detail bespreken en de wijzigingen in de context van een parallel systeem bespreken.

\paragraph{}
\emph{AdapHH} is een hyperheuristiek die de gegeven tijd opdeelt in fases. Het maakt gebruik van twee mechanismes die een effici\"ente sequentie genereren: \emph{Adaptive Dynamic Heuristic Set (ADHS)} en \emph{Relay Hybridisation (RH)}. \emph{ADHS} onderhoudt een tabu-set van heuristieken die in het verleden tot sterke resultaten hebben geleid. Heuristieken die niet aan dit criterium voldoen, worden enkele fases uit de set gehaald en daarna opnieuw ge\"introduceerd. Het \emph{RH} component werkt met een \emph{learning automaton}\cite{learningAutomaton} en voert twee heuristieken na elkaar uit. De twee mechanismes worden door elkaar gebruikt. Telkens wanneer \'e\'en van de twee mechanismen een nieuwe oplossing berekend, zal het \emph{Adaptive Iteration Limited List-based Threshold Accepting (AILLA)}-component beslissen of de nieuwe oplossing als actieve oplossing wordt aanvaard.

\subsubsection{ADHS: Adaptive Dynamic Heuristic Set}
\emph{AdapHH} probeert een set van sterke heuristieken te onderhouden. Hiervoor werkt het algoritme in fases. Een heuristiek wordt beoordeelt volgens de prestaties die het sinds de start heeft afgelegd, maar de prestaties in de laatste fase wegen zwaarder door in het besluit of een hyperheuristiek in de set blijft of enkele fases niet meer wordt gebruikt. Om heuristieken te evalueren wordt van volgende metriek gebruik gemaakt:
\begin{align*}
\funm{eval}{h_i}\isdefinedas{}&w_1\cdot\fbrk{\brak{1+\fun{C_{f,\smbox{best}}}{h_i}}\cdot t_{\smbox{rem.}}/t_{f,\smbox{spent}}}\cdot b+\\
&w_2\cdot\fbrk{\fun{f_{f,\smbox{imp}}}{h_i}/t_{f,\smbox{spent}}}-w_3\cdot\fbrk{\fun{f_{f,\smbox{wrs}}}{h_i}/t_{f,\smbox{spent}}}+\\
&w_4\cdot\fbrk{\fun{f_{\smbox{imp}}}{h_i}/t_{\smbox{spent}}}-w_5\cdot\fbrk{\fun{f_{\smbox{wrs}}}{h_i}/t_{\smbox{spent}}}\\\\
b\isdefinedas{}&\krdelta{\exists h_j:\fun{C_{f,\smbox{best}}}{h_j}>0}
\end{align*}
Met $C_{\smbox{best}}$ het aantal globaal betere oplossingen die de heuristiek heeft gevonden, $f_{\smbox{imp}}$ en $f_{\smbox{wrs}}$ de totale verbetering en verslechtering die de heuristiek veroorzaakt heeft. $t_{\smbox{spent}}$ houdt de totale rekentijd van een specifieke heuristiek bij. Indien er een subscript $f$ bij de metrieken wordt geplaatst, gaat het om de metriek in de laatste fase.

\paragraph{}
Een logische stap naar parallellisatie is het doorsturen van van de componenten van de metriek en vervolgens een uitspraak doen op basis van meer gegevens. Dit wordt echter bemoeilijkt door het feit dat de fases niet synchroon verlopen en dit bovendien de semantiek van een fase onderuit zou halen: uitspraken doen over hoe goed de heuristieken werken op een set gelijkaardige populaties. De metriek bevat echter ook enkele componenten die niet minder afhankelijk zijn van de laatste fase. Daarom introduceren we twee nieuwe termen die een uitspraak doen over het globale plaatje:
\begin{align*}
\funm{eval'}{h_i}\isdefinedas{}&w_1\cdot\fbrk{\brak{1+\fun{C_{f,\smbox{best}}}{h_i}}\cdot t_{\smbox{rem.}}/t_{f,\smbox{spent}}}\cdot b+\\
&w_2\cdot\fbrk{\fun{f_{f,\smbox{imp}}}{h_i}/t_{f,\smbox{spent}}}-w_3\cdot\fbrk{\fun{f_{f,\smbox{wrs}}}{h_i}/t_{f,\smbox{spent}}}+\\
&w_4\cdot\fbrk{\fun{f_{\smbox{imp}}}{h_i}/t_{\smbox{spent}}}-w_5\cdot\fbrk{\fun{f_{\smbox{wrs}}}{h_i}/t_{\smbox{spent}}}\\
&w_6\cdot\fbrk{\fun{f_{g,\smbox{imp}}}{h_i}/t_{g,\smbox{spent}}}-w_7\cdot\fbrk{\fun{f_{g,\smbox{wrs}}}{h_i}/t_{g,\smbox{spent}}}
\end{align*}
Waarbij het subscript $g$ betekent dat het gaat over de som van de gegevens van alle processoren. De gegevens worden op geregelde tijdstippen doorgestuurd om minder bandbreedte en rekenwerk aan boekhoudkundige taken toe te wijzen.

\paragraph{}
Op basis van de evaluatie worden de heuristieken gerangschikt met een kwaliteitsindex. De heuristieken met een kwaliteitsindex die onder het gemiddelde ligt, worden uit voor een periode van $\sqrt{2\cdot n}$ uit de set verwijdert (met $n$ het aantal heuristieken). Heuristieken die tijdelijk niet meer tot de set behoren worden hebben allemaal een kwaliteitsindex van $1$. Indien een heuristiek de fase nadat deze terug in de set werd ge\"introduceerd opnieuw wordt verwijdert, neemt het aantal fases toe. Indien het aantal tabu-fases verdubbelt is, wordt de heuristiek definitief verwijdert.

\paragraph{}


\subsubsection{RH: Relay Hybridisation}
Naast \emph{ADHS} is \emph{RH} ook een mechanisme om heuristieken te selecteren. Per iteratie in de fase zal met stijgende kans dit mechanisme geactiveerd worden. Op basis van een \emph{learning automaton} wordt een heuristiek gesecteerd die wordt toegepast op de actieve oplossing. Elke heuristiek onderhoud een lijst met heuristieken die effectief bleken als tweede transitiefunctie. Met een bepaalde kans wordt een heuristiek uit deze lijst geselecteerd. In het andere geval wordt er een toevallige heuristiek geselecteerd. Die tweede heuristiek wordt dan toegepast op het resultaat van de eerste heuristiek. De \emph{learning automaton} gebruik een \emph{lineair reward-interaction update schema} waardoor combinaties die globaal betere oplossingen vinden meer kans maken in de volgende iteraties.

\paragraph{}
In het geval van een \emph{learning automaton}, is \emph{mimetism} een populaire oplossing: het nabootsen van de toestanden van de andere processen. Na elke fases stuurt het proces de verschillen in de kansvector door naar de andere processoren. Deze verschillen worden gedeeltelijk doorgerekend. Door de wijzigingen slechts gedeeltelijk door te rekenen, hopen we voorkomen dat de kansvectoren uit de hand kunnen lopen.

\subsubsection{AILLA}
Nadat \'e\'en van de twee mechanismes (\emph{ADHS} of \emph{RH}) een nieuwe oplossing heeft gegenereerd, zal de heuristiek beslissen of deze oplossing de nieuwe actieve oplossing wordt. Dit is de verantwoordelijkheid van \emph{AILLA}. \emph{AILLA} beschouwd twee verschillende gevallen:
\begin{enumerate}
 \item In het geval de gegenereerde oplossing beter is dan de originele oplossing, wordt deze altijd geaccepteerd.
 \item In het andere geval wordt de oplossing alleen geaccepteerd wanneer de fitness-waarde beter is dan de fitness-waarde een historisch beste oplossing. Hiervoor onderhoud \emph{AILLA} een lijst van de laatste globaal beste oplossingen. Het aantal maal tot nu toe na elkaar het accepteren van een oplossing werd geweigerd bepaald hoe diep er terug in het verleden wordt gekeken om een oplossing alsnog te accepteren.
\end{enumerate}

\importtikz[1.4]{ailla}{ailla}{Werkingsprincipe van \emph{AILLA}.}

\imgref{ailla} illustreert dit principe. Op de figuur worden de verschillende mogelijke configuraties voorgesteld door de horizontale as. De verticale as geeft de fitness-waarde van de overeenkomstige configuratie weer. Wanneer we reeds enkele oplossingen hebben overlopen, hebben we enkele fitness-waardes. Deze waardes worden door de dunne grijze horizontale lijnen voorgesteld. Een oplossing zal altijd geaccepteerd worden wanneer deze zich onder de tot dan toe onderste horizontale lijn bevindt. Wanneer we een oplossing vanuit $x_4$ genereren ($x_4'$) zien we dat aan deze eis niet wordt voldaan. Daarom zullen we de eerste maal de oplossing verwerpen. Wanneer we dit de tweede maal een oplossing genereren ($x_4''$), moet deze zich enkel onder de op \'e\'en na onderste lijn bevinden. Opnieuw voldoet de oplossing niet aan de voorwaarde. De derde oplossing ($x_5$) ten slotte bevindt zich onder de op twee na onderste lijn. Daarom wordt deze oplossing wel geaccepteerd. Merk op dat $x_5$ een slechtere oplossing vormt dan $x_4'$.

\paragraph{}
We kunnen dit systeem verreiken door in de lijst van beste fitness-waardes ook de resultaten van andere processoren op te nemen. Hierdoor streven we naar sterkere stijgingen. Bovendien verwachten we dat dit op termijn gehaald zal worden: er worden immers ook oplossingen uitgewisseld waar andere processoren dan gebruik van kunnen maken. Door echter te strenge grenzen op te leggen kan een processor veel iteraties nodig hebben alvorens een nieuwe oplossing zal geaccepteerd worden. Daarom werd dit systeem aangepast zodat hooguit de helft van de lijst bestaat uit vreemde fitness-waardes.

\subsubsection{Andere componenten}

\paragraph{Kruisingsheuristieken}
In het geval \emph{AdapHH} een kruisingsoperator selecteert, dient men een andere oplossing te selecteren. In dat geval kiest \emph{AdapHH} een historisch beste oplossing. Dit hoeven niet noodzakelijk de laatste beste oplossingen te zijn. Telkens wanneer er immers een nieuwe beste oplossing wordt gevonden, wordt dit op een willekeurige plaats in een lijst met vaste grootte gezet. We kunnen het uitwisselingsmechanisme van \emph{ParHyFlex} uitbuiten: in plaats van uitsluitend te kiezen uit de lijst van lokale oplossingen, kunnen ook oplossingen die door een andere machine werden gegenereerd en doorgestuurd worden gebruikt.

\subsubsection{Overzicht}

\importtikz[1]{adaphhwerking}{paradaphh}{Werking van \emph{ParAdapHH}.}